## Redis

### 缓存雪崩

什么是缓存雪崩？

缓存雪崩是因为大面积的缓存失效，打崩了DB；原因是由于缓存过期时间一致，导致在一段时间内大量缓存过期，请求全部转发到DB，DB瞬时压力过重雪崩。

如何解决？

原因是因为缓存和DB处理能力不同。大量的请求落在DB,承受不了，进而崩溃。

1. 解决办法就是避免同时过期，可以增加在ttl再增加随机值
2. 使用集群，将热点数据落在不同节点，避免同时失效
3. 设置热点数据永不过期，有更新操作就更新缓存就好了

### 缓存穿透

什么是缓存穿透？

缓存穿透是指**查询一个一定不存在的数据**，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。而用户（黑客）不断发起请求，这就是漏洞。

如何解决？

1. 对于空数据同样写入缓存，null
2. 利用布隆过滤器
3. 黑名单、用户鉴权

### 缓存击穿

什么是缓存击穿？

缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。并发的请求可能会瞬间把后端DB压垮。

如何解决？

1. 永不过期，然后通过定时job去刷新缓存
2. 使用互斥锁(mutex key):这种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了。

### 内存淘汰策略

1. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。

2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。

3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。

4. volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。

5. allkeys-lru：从数据集中挑选最近最少使用的数据淘汰

6. allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。

7.  allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

8. no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。

### Redis事务

Redis 可以通过 **`MULTI`，`EXEC`，`DISCARD` 和 `WATCH`** 等命令来实现事务功能。不支持原子性，没法进行rollback。

**原理：**

[`MULTI`](https://redis.io/commands/multi)  可以等待输入多个命令进入队列，调用`EXEC`命令后，才真正执行所有命令。

[`DISCARD`](https://redis.io/commands/discard) 命令取消一个事务，它会清空事务队列中保存的所有命令。

[`WATCH`](https://redis.io/commands/watch) 命令用于监听指定的键，当调用 `EXEC` 命令执行事务时，如果一个被 `WATCH` 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。